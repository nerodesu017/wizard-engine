// Copyright 2023 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A general-purpose profiler.
def E = MonitorRegistry.register(
	"profile", "Reports execution time for entire calling context trees.",
	ProfileMonitor.new());
def depth = E.newIntOption("depth", "limit the maximum call tree depth", -1);
def filter = E.newFilterOption("calls", "apply profiling to selected functions");

class ProfileMonitor extends Monitor {
	var tree: ProfileTree;

	def onParse(module: Module) {
		var mm = ModuleMonitor.new(module);
		tree = ProfileTree.new();
		mm.forEachFunc(isFuncMonitored, mm.beforeFuncExecAndReturn(_, tree.enterFunc, tree.exitFunc));
	}
	def onExit(code: int) {
		while (tree.curNode != null) tree.pop();
		onFinish(null);
	}
	def onFinish(i: Instance) {
		tree.rootNode.render(0, 0, depth.val);
	}

	private def isFuncMonitored(module: Module, func: FuncDecl) -> bool {
		return !MonitorUtil.isImport(module, func) && (filter == null || filter.val.matches(module, func));
	}
}

def OUT = Trace.OUT;
private class ProfileTreeNode(parent: ProfileTreeNode, func: WasmFunction) {
	var children: List<ProfileTreeNode>;
	var totalTime: int;
	var curTime: int;
	var count: int;
	def thresholds = [75, 25, 10];

	def getOrCreateChild(func: WasmFunction) -> ProfileTreeNode {
		for (i = children; i != null; i = i.tail) {
			if (i.head.func == func) return i.head;
		}
		var childNode = ProfileTreeNode.new(this, func);
		children = List.new(childNode, children);
		return childNode;
	}
	def enter() {
		curTime = System.ticksUs();
		count++;
	}
	def exit() {
		totalTime += System.ticksUs() - curTime;
	}

	def render(depth: int, total: int, max: int) {
		var totalPercentTime = if(depth == 1, totalTime, total);
		var nestedTime: int = totalTime;
		var selfTime: int = totalTime;

		var childArray = Lists.toArray(children);
		childArray = Arrays.sort(childArray, 0, childArray.length, byTime);

		if (max == -1 || depth < max) {
			var childTotalTime = 0;
			for (i < childArray.length) {
				childTotalTime += childArray[i].totalTime;
			}
			selfTime = nestedTime - childTotalTime;
		} else {
			selfTime = -1;
		}

		if (func == null) {
			// Root node in ProfileTree
			renderHeader();
		} else {
			var l = OUT.length;
			var f = func.decl;
			for (i < depth) OUT.puts("  ");
			OUT.puts(Palette.FUNC);
			OUT.puts("func ");
			f.render(func.instance.module.names, OUT);
			OUT.puts(Palette.DEFAULT);
			OUT.pad(' ', l + 50);
			OUT.rjustify(' ', TraceUtil.renderUs(OUT, nestedTime), 12);
			OUT.rjustify(' ', TraceUtil.renderUs(OUT, selfTime), 12);
			if (totalPercentTime == 0) {
				OUT.puts(Palette.UNREACHABLE);
				OUT.rjustify(' ', TraceUtil.renderPercent(OUT, 0, 1, 3), 10);
			}
			else {
				var percenti = 100 * selfTime / totalPercentTime;
				if (percenti > thresholds[0]) OUT.puts(Palette.spectrum[0]);
				else if (percenti > thresholds[1]) OUT.puts(Palette.spectrum[1]);
				else if (percenti > thresholds[2]) OUT.puts(Palette.spectrum[2]);
				OUT.rjustify(' ', TraceUtil.renderPercent(OUT, selfTime, totalPercentTime, 3), 10);
			}
			OUT.rjustify(' ', TraceUtil.renderedLength(OUT, TraceBuilder.putd(_, count)), 10);
			OUT.outln();
		}

		if (max == -1 || depth < max) {
			for (child in childArray) {
				if (child != null) child.render(depth + 1, totalPercentTime, max);
			}
		}
	}
	private def byTime(a: ProfileTreeNode, b: ProfileTreeNode) -> bool {
		return b.totalTime < a.totalTime;
	}

	private def renderHeader() {
		var l = OUT.length;
		var padding = 50;
		if (WizengOptions.color) padding -= TermColors.WHITE.length;
		OUT.puts(Palette.SEPARATOR);
		OUT.puts("  *");
		OUT.pad(' ', l + padding);
		OUT.rjustify(' ', TraceUtil.renderedLength(OUT, TraceBuilder.puts(_, "nested")), 12);
		OUT.rjustify(' ', TraceUtil.renderedLength(OUT, TraceBuilder.puts(_, "self")), 12);
		OUT.rjustify(' ', TraceUtil.renderedLength(OUT, TraceBuilder.puts(_, "self %")), 10);
		OUT.rjustify(' ', TraceUtil.renderedLength(OUT, TraceBuilder.puts(_, "count")), 10);
		OUT.puts(Palette.DEFAULT);
		OUT.outln();
	}
}

private class ProfileTree {
	var rootNode: ProfileTreeNode;
	var curNode: ProfileTreeNode;

	new() {
		rootNode = ProfileTreeNode.new(null, null);
		curNode = rootNode;
	}
	def enterFunc(dynamicLoc: DynamicLoc) -> Resumption {
		curNode = curNode.getOrCreateChild(dynamicLoc.func);
		curNode.enter();
		return Resumption.Continue;
	}
	def exitFunc(dynamicLoc: DynamicLoc) -> Resumption {
		pop();
		return Resumption.Continue;
	}
	def pop() {
		curNode.exit();
		curNode = curNode.parent;
	}
}
