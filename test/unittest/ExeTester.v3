// Copyright 2024 Wizard authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def NO_IMPORTS = Array<Exportable>.new(0);

def array_r(obj: Object) -> Array<Value> {
	return [Value.Ref(obj)];
}
class ExeTester(t: Tester, tiering: ExecutionStrategy) extends ModuleBuilder {
	var max_call_depth = 100u;
	var imports = NO_IMPORTS;
	var args: Array<Value>;

	new() {
		Execute.reset();
		// TODO: Execute.tiering being global state makes testing awkward.
		Execute.tiering = if(tiering == null, ExecuteOptions.default, tiering);
	}

	def codev(raw: Array<byte>) -> this {
		code(raw);
		var err = ErrorGen.new(module.filename);
		var v = CodeValidator.new(extensions, Limits.new().set(extensions), module, err);
		if (tiering != null) tiering.onFuncValidationStart(module, func);
		var r = v.validateFunc(func);
		if (tiering != null) tiering.onFuncValidationFinish(module, func, err);
		match (r) {
			Ok => ;
			Error(error, pc, msg) => t.fail2("invalid code @+%d: %s", pc, msg);
		}
	}
	def run(args: Array<Value>) -> (Instance, Result) {
		var err = ErrorGen.new("ExeTest.v3");
		var instance = Instantiator.new(extensions, module, imports, err).run();
		if (!err.ok()) {
			t.fail(err.error_msg);
			return (instance, Traps.result(TrapReason.ERROR));
		}
		var f = instance.functions[0];
		if (tiering != null) {
			if (WasmFunction.?(f)) tiering.onTestRun(WasmFunction.!(f), err);
			if (!err.ok()) {
				t.fail(err.error_msg);
				return (instance, Traps.result(TrapReason.ERROR));
			}
		} else {
			if (TestTiers.preprocess != null) TestTiers.preprocess(module);
		}
		Execute.limits.max_call_depth = max_call_depth;
		if (Trace.interpreter) {
			Trace.OUT.puts("run ");
			Values.renderVals(Trace.OUT, args);
			Trace.OUT.outln();
		}
		var r = Execute.call(f, args);

		if (Trace.interpreter) {
			Trace.OUT.put1(" -> %q\n", r.render).outln();
		}
		return (instance, r);
	}
	def noargs() -> this					{ args = Values.NONE; }
	def argsN(x: Array<Value>) -> this			{ args = x; }
	def args_i(x: i32) -> this				{ args = [Value.I32(u32.view(x))]; }
	def args_u(x: u32) -> this				{ args = [Value.I32(x)]; }
	def args_l(x: i64) -> this				{ args = [Value.I64(u64.view(x))]; }
	def args_w(x: u64) -> this				{ args = [Value.I64(x)]; }
	def args_f(x: u32) -> this				{ args = [Value.F32(x)]; }
	def args_d(x: u64) -> this				{ args = [Value.F64(x)]; }
	def args_q(x: u64, y: u64) -> this			{ args = [Value.V128(x, y)]; }
	def args_r(x: Object) -> this				{ args = [Value.Ref(x)]; }
	def args_ii(x: i32, y: i32) -> this			{ args = [Value.I32(u32.view(x)), Value.I32(u32.view(y))]; }
	def args_uu(x: u32, y: u32) -> this			{ args = [Value.I32(x), Value.I32(y)]; }
	def args_uuu(x: u32, y: u32, z: u32) -> this		{ args = [Value.I32(x), Value.I32(y), Value.I32(z)]; }
	def args_ll(x: i64, y: i64) -> this			{ args = [Value.I64(u64.view(x)), Value.I64(u64.view(y))]; }
	def args_ww(x: u64, y: u64) -> this			{ args = [Value.I64(x), Value.I64(y)]; }
	def args_ff(x: u32, y: u32) -> this			{ args = [Value.F32(x), Value.F32(y)]; }
	def args_dd(x: u64, y: u64) -> this			{ args = [Value.F64(x), Value.F64(y)]; }
	def args_qq(x: (u64, u64), y: (u64, u64)) -> this	{ args = [Value.V128(x), Value.V128(y)]; }

	def assert2_i(x: i32) -> this			{ assert_v(args, Value.I32(u32.view(x))); }
	def assert2_u(x: u32) -> this			{ assert_v(args, Value.I32(x)); }
	def assert2_l(x: i64) -> this			{ assert_v(args, Value.I64(u64.view(x))); }
	def assert2_w(x: u64) -> this			{ assert_v(args, Value.I64(x)); }
	def assert2_f(x: u32) -> this			{ assert_v(args, Value.F32(x)); }
	def assert2_d(x: u64) -> this			{ assert_v(args, Value.F64(x)); }
	def assert2_q(x: u64, y: u64) -> this		{ assert_v(args, Value.V128(x, y)); }
	def assert2_r(x: Object) -> this		{ assert_v(args, Value.Ref(x)); }
	def assert2_res(x: Result) -> this		{ assert_r(args, x); }
	def assert2_none() -> this			{ assert_r(args, Result.Value(Values.NONE)); }
	def assert2_trap(reason: TrapReason) -> this	{ assert_trap(args, reason); }
	
	def assert_mem(args: Array<Value>, offset: u32, expected: Array<byte>) {
		var tr = run(args), instance = tr.0, r = tr.1;
		checkNop(r);
		if (instance == null) return t.fail("instance is null");
		var mem = instance.memories[0];
		if (mem == null) return t.fail("memory is null");
		for (i < expected.length) {
			var addr = int.!(offset) + i;
			var got = mem.read_u8(0, u32.view(addr)).result;
			if (expected[i] != got) return t.fail3("expected mem[%x] = %x, got %x", addr, expected[i], got);
		}
	}
	def assert_ftable(args: Array<Value>, offset: u32, expected: Array<FuncDecl>) {
		var tr = run(args), instance = tr.0, r = tr.1;
		checkNop(r);
		var elems = instance.tables[0].elems;
		if (elems.length < expected.length) return t.fail2("expected table.length >= %d, got %d", expected.length, elems.length);
		for (i < expected.length) {
			var addr = int.!(offset) + i;
			var exp = expected[i];
			var got = Value.Ref.!(elems[addr]).val;
			if (exp == null) {
				if (got != null) return t.fail1("expected table[%d] == null", addr);
			} else {
				if (!WasmFunction.?(got)) return t.fail2("expected table[%d] : WasmFunction%s ", addr, if(got == null, ", got null", ""));
				var wgot = WasmFunction.!(got);
				if (exp != wgot.decl) return t.fail3("expected table[%d] = #%d, got #%d", addr, expected[i].func_index, wgot.decl.func_index);
			}
		}
	}
	def assert_r(args: Array<Value>, expected: Result) -> Result {
		var got = run(args).1;
		assert_req(got, expected);
		return got;
	}
	def assert_req(got: Result, expected: Result) {
		if (!expected.equals(got)) t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_v(args: Array<Value>, expected: Value) {
		assert_r(args, Result.Value([expected]));
	}
	def assert_nan(args: Array<Value>) {
		var got = run(args).1;
		match (got) {
			Value(vals) => match (vals[0]) {
				F32(bits) => if (Floats.isNan32(bits)) return;
				F64(bits) => if (Floats.isNan64(bits)) return;
				_ => ;
			}
			_ => ;
		}
		t.fail1("expected NaN, got %q", got.render);
	}
	def assert_g(args: Array<Value>, findex: int) {
		var r = run(args), instance = r.0, got = r.1;
		var expected = Result.Value([Value.Ref(instance.functions[findex])]);
		if (expected.equals(got)) return;
		t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_trap(args: Array<Value>, expected: TrapReason) {
		assert_r(args, Traps.result(expected));
	}
	def assert_trap_at(args: Array<Value>, expected: TrapReason, pcs: Array<int>) {
		var got = assert_r(args, Traps.result(expected));
		match (got) {
			Throw(thrown) => match (thrown) {
				x: Trap => {
					if (x.stacktrace == null) return t.fail("expected stacktrace, but none");
					var f = x.stacktrace.frames;
					if (f == null) return t.fail("expected stacktrace frames, got null");
					if (f.length != pcs.length) return t.fail2("expected %d stacktrace frame, got %d", pcs.length, f.length);
					for (i < pcs.length) {
						var pc = pcs[i], gotpc = f[i].1;
						if (gotpc != pc) return t.fail3("expected @ frame %d, pc=%d, got pc=%d", i, pc, gotpc);
					}
				}
				_ => t.fail("expected trap, got other error");
			}
			_ => t.fail("expected trap");
		}
	}
	def assert_nop(args: Array<Value>) {
		var r = run(args);
		checkNop(r.1);
	}
	def assert_val1<V>(got: Result, kind: string) -> (bool, V) {
		match (got) {
			Value(vals) => if (vals.length == 1) {
				var v = vals[0];
				if (V.?(v)) return (true, V.!(v));
			}
			_ => ;
		}
		t.fail2("expected 1 %s value, got %q", kind, got.render);
		var d: V;
		return (false, d);
	}
	def assert_struct(got: Result, expected_struct: StructDecl, rtt: HeapTypeDecl, fields: Array<Value>) {
		var r = assert_val1<Value.Ref>(got, "struct"), ok = r.0, hr = r.1;
		if (!ok) return;
		if (!HeapStruct.?(hr.val)) return t.fail1("expected struct, got %q", got.render);
		var obj = HeapStruct.!(hr.val);
		if (obj.decl != expected_struct) return t.fail2("expected heap %q, got %q",
			expected_struct.render, obj.decl.render);
		if (rtt != null && obj.decl != rtt) return t.fail2("expected rtt %q, got %q", rtt.render, obj.decl.render);
		t.assertar("fields", fields, obj.vals, Values.render);
	}
	def assert_array(got: Result, expected_array: ArrayDecl, rtt: HeapTypeDecl, elems: Array<Value>) {
		var r = assert_val1<Value.Ref>(got, "array"), ok = r.0, hr = r.1;
		if (!ok) return;
		if (!HeapArray.?(hr.val)) return t.fail1("expected array, got %q", got.render);
		var obj = HeapArray.!(hr.val);
		if (obj.decl != expected_array) return t.fail2("expected heap %q, got %q",
			expected_array.render, obj.decl.render);
		if (rtt != null && obj.decl != rtt) return t.fail2("expected rtt %q, got %q", rtt.render, obj.decl.render);
		t.assertar("elements", elems, obj.vals, Values.render);
	}
	def checkNop(r: Result) {
		match (r) {
			Throw(thrown) => t.fail1("unexpected trap: %q", thrown.render);
			Value(vals) => {
				var len = if(vals != null, vals.length);
				if (len > 0) t.fail1("expected no values, got %d value(s)", len);
			}
			Suspend(stack, tag, valrefs) => {
				t.fail1("unexpected suspend: %q", tag.render);
			}
		}
	}
}

